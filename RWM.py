import numpy as np
from numpy import zeros, log, eye, vstack
from numpy.random import default_rng, randint
from scipy.stats import multivariate_normal as MVN


def RWM(x0, s, N, logpi, rng=None):
    """Random Walk Metropolis sampler with proposal N(x, (s**2)*I). 
    
    Arguments:

    :param x0: Initial state of the Markov chain. Must have shape (d, ).
    :type x0: ndarray

    :param s: Scale for the proposal distribution. If x is the current state of the Markov Chain
              then the proposal is generated by sampling from `N(x, (s**2)*np.eye(d))`, i.e. an isotropic
              multivariate normal distribution with variance s**2.
    :type s: float

    :param N: Number of samples.
    :type N: int

    :param logpi: Log-density of the target distribution from which we want to sample.
    :type logpi: callable

    :param rng: Random Number Generator for reproducibility. Typically will be an instance of 
                `np.random.default_rng(seed)`. If `None`, a `default_rng` will be created with a 
                randomly-generated seed.
    :type rng: np.random.Generator

    Returns:

    :param samples: Numpy array containing `N` samples. Has shape `(N, d)`.
    :type samples: ndarray

    :param acceptances: Numpy array of length `N` containing `1` if the corresponding sample was 
                        accepted, or `0` otherwise.
    :type acceptances: ndarray
    """
    assert s >= 0, "Scale for the proposal distribution must be non-negative."
    assert N >= 1, "Number of samples must be at least 1."

    if rng is None:
        rng = default_rng(seed=randint(low=1000, high=9999))

    samples = x = x0                                   # Accepted samples will be stored here
    acceptances, logpx, d = zeros(N), logpi(x), len(x) # Accepted (=1), log(pi(x)), dimensionality
    logu = log(rng.uniform(size=N))                                # Used for Accept/Reject step

    for i in range(N):
        y = x + s*rng.normal(size=d)   # Sample candidate
        logpy = logpi(y)               # Compute its log density
        if logu[i] <= logpy - logpx:
            x, logpx, acceptances[i] = y, logpy, 1 # Accept! 
        samples = vstack((samples, x)) # Add sample to storage
    return samples[1:], acceptances